# inner(внутрішня) або closure(замкнута функція)
# Замикання в Python - це об'єкт функції, який має доступ до змінних в своєму лексичному середовищі, навіть коли функція викликається поза цим середовищем. 
# Простими словами, замикання дозволяє функції запам'ятовувати та отримувати доступ до змінних з оточення, в якому воно було створено, 
# навіть якщо функція виконується в іншому середовищі.

def main_func(name):
    def inner_func():
        print('hello my friend', name)  # Тут відбувається замикання. Вкладена ф-ця користується змінною яка не оголошена в її тілі. Причому,
    return inner_func                   # змінна name не видаляється.


#result = main_func('Vovik')
#new_result = main_func('Vovik')
#result()  # hello my friend
#new_result()  # hello my friend
main_func('vovik')()


def massage(x):
    def print_massage(y):
        return x + y
    return print_massage
 

numb = massage(10)
print(numb(10))  # 20


def calculate(a, b):
    def calculi():
        return a + b
    return calculi

s = calculate(10, 10)
print(s())  # 20

#>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
#>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>ПІСЛЯ ВИКЛИКУ ЛОКАЛЬНОЇ ФУНКЦІЇ ЗМІННІ ЗНИКАЮТЬ<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<
#>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>У ВИПАДКУ З CLOSURE ЗМІННА НЕ ЗНИКАЄ<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<
#<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<
#>>>>>>>>>Ідея замикання полягає в тому, що викликається функція, розміщується значення і ця функція буде пов'язаною з цією функцією<<<<<<<<<<<<<<<<<
#>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>><<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

def adder(value):  # створив просту функцію
    def inner(a):  # створив вкладену функцію
        return value + a
    return inner # створюється замикання. В тілі ф-ції adder вертається вкладена функція inner

# print(adder(2)(3))
s = adder(2)(3)
print(s) 


#  main_func('vovik')():
# У цьому випадку ви викликаєте функцію main_func('vovik'), яка повертає внутрішню функцію. Після цього ви відразу викликаєте отриману внутрішню функцію, використовуючи другий набір круглих дужок.
# Цей виклик функції має виведення print('hello my friend', 'vovik'), але вам не потрібно виводити його, оскільки функція вже виводить результат.

# print(adder(2)(3)):
# У цьому випадку ви викликаєте функцію adder(2), яка повертає внутрішню функцію. Потім ви відразу викликаєте цю внутрішню функцію, передаючи аргумент 3.
# Результат виклику внутрішньої функції є числовим значенням (у цьому випадку 5). Однак, щоб вивести це значення, ви використовуєте функцію print.

# Use bash:
# python3
# copy code and practise


#>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
#>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>IMPORTANT<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<
#↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓

def say_name(name):
    def say_goodbye():
        print(f"Don't say me goodbye, {name}")
    return say_goodbye

s = say_name('Vovik')
s()  

# Коли є глобальне посилання на внутрішнє локальне середовище, тоді це середовище продовжується існувати! А разом з локальним середовщием продовжують
# інстувати всі інші зовнішні середовища які з ним пов'язані.

# s() --> say_goodbye --> say_name(name='Vovik') --> s() замикання 

#####################################################################################################################################################
def counter(start=0):
    def step():
        nonlocal start
        start += 1
        return start
    
    return step


s = counter(10)
s1 = counter()
print(s(), s1())


def strip_string(strip_chars=' '):
    def do_strip(string):
        return string.strip(strip_chars)
    return do_strip


strip1 = strip_string()
strip2 = strip_string(" !?,.,;")

print(strip1('hello python!.. '))
print(strip2('hello python!.. '))

#############################################################
def calculate(a, b):
    def calculi():
        return a * b
    return calculi

s = calculate(2, 4)
print(s())


def calc(a, b):
    return a * b

print(calc(2, 4))

