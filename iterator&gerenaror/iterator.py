list(range(5))  # [0, 1, 2, 3, 4]
a = iter(range(5))  # <range_iterator object at 0x7f4d18b578d0>
print(next(a))  # 0
print(next(a))  # 1
print(next(a))  # 2
print(next(a))  # 3
print(next(a))  # 4
#print(next(a))  # Error: 'StopIteration"

for x in list(range(5)):  # 0
    print(x)              # 1
                          # 2
                          # 3

# Ітератор - об'єкт, що представляє потік даних:
s = 'Рядок'
s_itr = iter(s)
s_itr
#print(s_itr)  # <str_iterator object at 0x7efeb7156a10>
# print(next(s))  #'str' object is not an iterator
print(s_itr.__next__())
#print(next(s_itr))
# __iter__ і __next__ - це два методи, які визначають ітератор в Python. Розглянемо їхню різницю:

# __iter__:

# Метод __iter__ повертає сам об'єкт ітератора.
# Викликається при створенні ітератора, зазвичай повертає self.
# Цей метод може бути визначений в класі, який також реалізує метод __next__, або в окремому класі, який реалізує метод __next__.

# __next__:

# Метод __next__ повертає наступний елемент послідовності або піднімає виняток StopIteration, якщо елементів не залишилося.
# Викликається при виклику функції next() або під час ітерації циклом for.
# Якщо метод __next__ визначено в класі, але метод __iter__ не визначено, клас вважається ітератором, і __iter__ автоматично надається за замовчуванням (повертає self).
# Основна ідея полягає в тому, що об'єкт, який реалізує ітератор, повинен мати метод __iter__, який повертає самого себе, і метод __next__, який повертає наступний елемент. Коли ітератор вичерпується (не має більше елементів), метод __next__ повинен підняти виняток StopIteration.

# В прикладі класу ітератора, показаному раніше, __iter__ повертає самого себе (об'єкт ітератора), а __next__ реалізований для повернення наступного елемента послідовності.
    



    